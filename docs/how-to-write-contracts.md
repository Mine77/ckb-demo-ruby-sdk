# Introduction

This document explains how to write new scripts for CKB.

# Transaction Model

Below is an example of CKB's transaction:

![Transaction Model](/docs/images/tx.png)

> Note that to focus on explaining script model, certain fields in a cell (such as `data`) are not mentioned here for the simplicity.

In CKB, each cell has 2 associated scripts:

* **A required lock script.** (Note that cell usually only keeps the hash of the actual lock script, we will explain this later.) Lock script is used to verify *who* can unlock the cell. For example, we can put secp256k1 verification in a lock script to verify a signature is indeed signed by the cell owner, which makes the cell can only be unlocked when a valid signature is provided.
* **An optional type script.** Type script is used to verify *how* one can use the cell, for example, type script can be used to ensure that no new tokens are created out from the air when transferring user-defined tokens.

When unlocking a cell in a transaction, there should be an unlock script along with the cell in the transaction's input part. The hash of the unlock script should match the `lock` field of the referenced cell(in other words, we are using `P2SH` scheme here). So another way of looking at this problem here, is that it is the `lock` field of the cell that really determines what unlock script can be used here, and we can treat `lock` and `unlock` here as the same thing.

In addition to the different use cases, lock script and type script are also executed at different time: lock script is executed when we are *unlocking* a cell, while type script is executed when we are *creating* a cell. In the case of validating the transaction in the above example, we only execute `Lock 1`, `Lock 2`, `Type 3` and `Type 4` here.

## Script Model

Both lock and type scripts are represented using the [Script](https://github.com/Mine77/ckb/blob/master/docs/data-structures.md#Script) model. Fields in this model include:

* `version`: version field is used to resolve incompatible upgrades.
* `binary`: ELF formatted binary containing the actual RISC-V based script
* `reference`: if your script already exists on CKB, you can use `reference` field to *refer* this existed on-chain script, instead of including its binary in the script again. You can simply put the script hash (will explain later how this is calculated) in this `reference` field, then list the cell that contains the script as a `deps` in the current transaction. CKB would automatically locate cell, load the binary from the referred script and use it as the `binary` field of this script. Note that this only works when there's no value provided in the `binary` field , otherwise the value in the `binary` field always take precedence.
* `signed_args`: Signed arguments, we will explain later what they are and how to distinguish them from `args`.
* `args`: Normal arguments.

CKB scripts use UNIX standard execution environment. Each script binary should contain a main function with the following arguments:

```c
int main(int argc, char* argv[]);
```

When the script data is loaded in an CKB-VM instance, `signed_args` and `args` will be concatenated into an array to fill the `argc`/`argv` part, and then the script execution will be started. Upon termination, the executed `main` function here will provide a return code. A return code of `0` means that the script execution was succeeded, other values may indicate that the execution was failed.

`signed_args` is introduced here to enable script sharing: assuming 2 CKB users both want to use secp256k1 algorithm in the to secure their cells, in order to do this, they both will need a lock script with secp256k1 verification. The scripts will also need to include their public key respectively, for verifying signatures. 

Now, if they both include their own public key directly in the script binary, the difference of their public keys will lead to the difference of their script binaries, which result in two different scripts and script hashes. This is quite a waste of resource, considering the majority part of these 2 scripts here are exactly the same. 

To improve the resource reuse rate, it is recommended to put two different public keys in the `signed_args` part of the script model, instead of including them in the `binary` directly, then make use of the same secp256k1 script binary. In this way, resources are largely saved while preserving the different ownerships. This might not be a huge amount of savings when we are only considering 2 users, but as the number of users grow, the resource we can save with this scheme is huge.

> **Confusion Alert:** `signed_args` is not generated by signing the `args` parameters. As mentioned above, `signed_args` is designed to improve the code reuse rate by putting the non-reusable codes in the `signed_args` field (which is usually signatures, hence the notation of "signed args"), and putting reusable codes in the `binary` filed (or refer from other script via `reference` field). So `signed_args` is actually part of the script, whereas `args` is the input arguments for the scripts, which means `args` is actually NOT a part of the script. This is counterfactual considering the current data structure of `script`. It is promising that this will be fixed this in the future iteration...

<!-- to do : add confusion alert for `type_hash` and `version` and `signed_args` -->

Each script has a `type_hash` which uniquely identifies the script. This is typically used in two places:
* **Referring script for a cell's `lock`.** In a transaction, there's a group of inputs. Each input has an input cell and an unlock script. In order to make this transaction valid, the `type_hash` of the unlock script should be identical to the hash filled in the `lock` field of the input cell. This can also be thought as the input cell referrers its unlock script through the `type_hash` of the unlock script.
* **Referring script for a cell's `type`.**In the outputs of a transaction, each output cell has a `type` field, which should be filled with the type script. If a type script needs to refer a script stored in another cell as the script binary instead of including the binary codes directly, then the `type_hash` of the referred script should be filled in the `reference` field.

When calculating the `type_hash` of a script, four parts will be used: `version`, `binary`, `reference` and `signed_args`. As mentioned above, `args` is not a part of the script while the `signed_args` is. So `args` is not included when calculating `type_hash` while `signed_args` is. For how to calculate `type_hash` in practice, please refer [this piece of code](https://github.com/nervosnetwork/ckb/blob/master/core/src/script.rs#L147). (`Version` is not really used because it is always `0` at this moment.)

> Confusion Alert: the term "type" in `type_hash` means that the `type_hash` is the identity to a group of `script`, instead of a single one. Each of these `script` share the same `binary`, `reference` and `signed_args`, but has different `args`. So these `script` can be categorized into a single "type", therefore their identifier is called `type_hash`.

In practice, one example script might look like following:

```json
{
  "version": 0,
  "reference": "0x12b464bcab8f55822501cdb91ea35ea707d72ec970363972388a0c49b94d377c",
  "signed_args": [
    "024a501efd328e062c8675f2365970728c859c592beeefd6be8ead3d901330bc01"
  ],
  "args": [
    "3044022038f282cffdd26e2a050d7779ddc29be81a7e2f8a73706d2b7a6fde8a78e950ee0220538657b4c01be3e77827a82e92d33a923e864c55b88fd18cd5e5b25597432e9b",
    "1"
  ]
}
```

This script uses `reference` field to refer to an existing cell for using its script `binary`. It contains one `signed_args` item, which is the public key of the current user. This script has 2 arguments for `args`: the first one is the signature calculated for the current transaction; the seconde part is flag for selecting the `sighash` type to be use in the script program. Please notice that the `signed_args` and `args` are only defined by the actual script binary. CKB system does not have any limitations to this part.

# Writing Scripts in Ruby

Here we will only explain how to write Ruby scripts with our custom [mruby-contracts](https://github.com/nervosnetwork/mruby-contracts). Note that we only user Ruby as an example here, it doesn't mean that CKB is only limited to scripts written in Ruby. On the contrary, CKB is extremely flexible and you can use almost any languages out there to write scripts. For example, you can use [micropython](https://micropython.org/) to enable writing CKB scripts in Python, or use [duktape](https://duktape.org/) to run JavaScript scripts on CKB. Of course if your focus is on the performance of the script, you can also directly use C to write scripts that extracts the maximum computing power out of CKB VM. When Rust's RISC-V port becomes more stable, you can also use Rust to write CKB scripts.

To help writing CKB scripts, we have ported [mruby](https://github.com/mruby/mruby) to CKB VM environment and also created several mruby libraries supporting CKB script development:

* mruby-sha3: A sha3 binding for mruby environment
* mruby-secp256k1: A secp256k1 binding for mruby environment
* mruby-ckb: CKB supporting libraries, including features to read transaction data as well as sending debug messages.

To build `mruby-contracts`, first follow the [setup steps](https://github.com/nervosnetwork/ckb-demo-ruby-sdk#configure-ckb) in the Ruby SDK. Then you can locate the mruby script cell via the Ruby SDK:

```ruby
[1] pry(main)> api = Ckb::Api.new
[2] pry(main)> api.mruby_cell_hash
[3] pry(main)> api.mruby_out_point
```

`mruby_cell_hash` should be used as `reference` field in the script you assembled. `mruby_out_point` should go in the deps part of the transaction you assembled. With that, you can put the Ruby script you want to run as the first signed argument in the script:

```json
{
  "version": 0,
  "reference": "0x12b464bcab8f55822501cdb91ea35ea707d72ec970363972388a0c49b94d377c",
  "signed_args": [
    "# This contract needs 1 signed arguments:\n# 0. pubkey, used to identify token owner\n# This contracts also accepts 2 required unsigned arguments and 1\n# optional unsigned argument:\n# 1. signature, signature used to present ownership\n# 2. type, SIGHASH type\n# 3. output(s), this is only used for SIGHASH_SINGLE and SIGHASH_MULTIPLE types,\n# for SIGHASH_SINGLE, it stores an integer denoting the index of output to be\n# signed; for SIGHASH_MULTIPLE, it stores a string of `,` separated array denoting\n# outputs to sign\nif ARGV.length != 3 && ARGV.length != 4\n  raise \"Wrong number of arguments!\"\nend\n\nSIGHASH_ALL = 0x1\nSIGHASH_NONE = 0x2\nSIGHASH_SINGLE = 0x3\nSIGHASH_MULTIPLE = 0x4\nSIGHASH_ANYONECANPAY = 0x80\n\ndef hex_to_bin(s)\n  if s.start_with?(\"0x\")\n    s = s[2..-1]\n  end\n  s.each_char.each_slice(2).map(&:join).map(&:hex).map(&:chr).join\nend\n\n\ntx = CKB.load_tx\nsha3 = Sha3.new\n\nsha3.update(ARGV[2])\nsighash_type = ARGV[2].to_i\n\nif sighash_type & SIGHASH_ANYONECANPAY != 0\n  # Only hash current input\n  outpoint = CKB.load_input_out_point(0, CKB::Source::CURRENT)\n  sha3.update(outpoint[\"hash\"])\n  sha3.update(outpoint[\"index\"].to_s)\n  sha3.update(CKB::CellField.new(CKB::Source::CURRENT, 0, CKB::CellField::LOCK_HASH).readall)\nelse\n  # Hash all inputs\n  tx[\"inputs\"].each_with_index do |input, i|\n    sha3.update(input[\"hash\"])\n    sha3.update(input[\"index\"].to_s)\n    sha3.update(CKB.load_script_hash(i, CKB::Source::INPUT, CKB::Category::LOCK))\n  end\nend\n\ncase sighash_type & (~SIGHASH_ANYONECANPAY)\nwhen SIGHASH_ALL\n  tx[\"outputs\"].each_with_index do |output, i|\n    sha3.update(output[\"capacity\"].to_s)\n    sha3.update(output[\"lock\"])\n    if hash = CKB.load_script_hash(i, CKB::Source::OUTPUT, CKB::Category::CONTRACT)\n      sha3.update(hash)\n    end\n  end\nwhen SIGHASH_SINGLE\n  raise \"Not enough arguments\" unless ARGV[3]\n  output_index = ARGV[3].to_i\n  output = tx[\"outputs\"][output_index]\n  sha3.update(output[\"capacity\"].to_s)\n  sha3.update(output[\"lock\"])\n  if hash = CKB.load_script_hash(output_index, CKB::Source::OUTPUT, CKB::Category::CONTRACT)\n    sha3.update(hash)\n  end\nwhen SIGHASH_MULTIPLE\n  raise \"Not enough arguments\" unless ARGV[3]\n  ARGV[3].split(\",\").each do |output_index|\n    output_index = output_index.to_i\n    output = tx[\"outputs\"][output_index]\n    sha3.update(output[\"capacity\"].to_s)\n    sha3.update(output[\"lock\"])\n    if hash = CKB.load_script_hash(output_index, CKB::Source::OUTPUT, CKB::Category::CONTRACT)\n      sha3.update(hash)\n    end\n  end\nend\nhash = sha3.final\n\npubkey = ARGV[0]\nsignature = ARGV[1]\n\nunless Secp256k1.verify(hex_to_bin(pubkey), hex_to_bin(signature), hash)\n  raise \"Signature verification error!\"\nend\n",
    "024a501efd328e062c8675f2365970728c859c592beeefd6be8ead3d901330bc01"
  ],
  "args": [
    "3044022038f282cffdd26e2a050d7779ddc29be81a7e2f8a73706d2b7a6fde8a78e950ee0220538657b4c01be3e77827a82e92d33a923e864c55b88fd18cd5e5b25597432e9b",
    "1"
  ]
}
```

As you can see from the code above, the first argument of `signed_args` here is actually a Ruby script. To execute this script, CKB will first load mruby into an CKB-VM instance, creating a Ruby interpreter environment. .Then the Ruby script will be entered into this Ruby environment and executed. If this Ruby script throws an exception, it will be translated into a non-zero return code, denoting a script execution error. If the script runs without any exceptions, and returned a code `0`, the script will be considered as successfully executed.

## Ruby Libraries

Even though Ruby is a powerful language, it cannot fulfill all the tasks without supporting libraries. We provide a series of Ruby libraries here for helping writing scripts.

### mruby-sha3

[mruby-sha3](https://github.com/nervosnetwork/mruby-contracts/tree/master/mruby-sha3) is a simple library providing Ruby bindings for sha3. The usage is as follows:

```ruby
sha3 = Sha3.new
sha3.update("abcdef")
# Only string is accepted as argument to the update method
sha3.update(5.to_s)
hash = sha3.final
```

### mruby-secp256k1

[mruby-secp256k1](https://github.com/nervosnetwork/mruby-contracts/tree/master/mruby-secp256k1) provides Ruby binding for secp256k1 algorithm. It provides the following APIs:

#### Fetch public key

```ruby
secret_key = "<I am a secret key>"
public_key = Secp256k1.pubkey(secret_key)
```

#### Sign message

```ruby
secret_key = "<I am a secret key>"
message = "<I am a 32 byte long message>"
signature = Secp256k1.sign(secret_key, message)
```

#### Verify signature

```ruby
public_key = "<I am a public key>"
signature = "<I am a signature>"
message = "<I am a 32 byte long message>"
verified = Secp256k1.verify(public_key, signature, message)
unless verified
  raise "Signature verification error!"
end
```

### mruby-ckb

[mruby-ckb](https://github.com/nervosnetwork/mruby-contracts/tree/master/mruby-ckb) provides wrapper functions to interact with CKB.

#### Debug

mruby-ckb provides a debug method to print debug messages to CKB:

```ruby
CKB.debug "I'm a debug message: ${5}"
```

#### Load Transaction

If we have the following snippet in a Ruby script:

```ruby
tx = CKB.load_tx
CKB.debug "TX: #{tx}"
```

We can then expect logs in CKB like following:

```
2018-12-17 16:03:21.650 +08:00 TransactionPoolService DEBUG script  Transaction 5c065df07094..(omit 40)..5bcdebf47e81, input 0 DEBUG OUTPUT: TX: {"version"=>0, "deps"=>[{"hash"=>"s+\xfdV\xf4v\x87\x05cm{J\x1dc\xbc\x01]\xff\xaf)\x8e!\xe2@Gx\xb5!\xc3\x17]\xca", "index"=>2}], "inputs"=>[{"hash"=>"d\x02\x11\v\x8f\eT\xe6\xce\xe9\xcej\x82\xf9_K\x97U\f\xe1\x92\xfe\xb2\xba_\x86\xe6\x90\xb5PW\xc5", "index"=>0}], "outputs"=>[{"capacity"=>35000, "lock"=>"\xfe\x1a\xc2\xd4\xa6\xd8R\xc3\x94t>\x98\x8f\xd2\xcf\x9eI\xa7j%5n|\x8b\#@\xf6X\xef\xbc,\x1f"}, {"capacity"=>15000, "lock"=>"\x98L\xb0\xc6\a\xe5\xfa7\x8fj\x85m\x02\xdf\x82Y\x0e\xf8T\xc6\xa2>\x15\xd2\f\xe5\xda\x9f\xa4\x9d\x8f\xb2"}]}
```

Here we can see the overall transaction structure is returned by `CKB.load_tx`

#### Load Script Hash

The following code can be used to load script hash:

```ruby
# Load cell input 1's unlock script hash, note lock and unlock refer to the same item.
# Return value here is a string of 32 bytes
CKB.load_script_hash(1, CKB::Source::INPUT, CKB::Category::LOCK)
# Load cell output 2's type script hash, note that type script is optional, so the
# returned value here could be nil
CKB.load_script_hash(2, CKB::Source::OUTPUT, CKB::Category::CONTRACT)
# Load current cell's lock hash
CKB.load_script_hash(0, CKB::Source::CURRENT, CKB::Category::LOCK)
```

#### Load Input OutPoint

If we have the following snippet in a Ruby script:

```ruby
CKB.debug "OutPoint: #{CKB.load_input_out_point(0, CKB::Source::CURRENT)}"
```

We can then expect logs in CKB like:

```
2018-12-17 16:10:44.185 +08:00 TransactionPoolService DEBUG script  Transaction f424348ef9d0..(omit 40)..8f79d68c82b4, input 0 DEBUG OUTPUT: OutPoint: {"hash"=>"#~\x9ekK23\xc7\x0f%\xaa\n\xa1\xc8\xc0\x81<\x948`B\xab\x9e\xb5\xe0\xea8\xe3r\xd3\x9e\x99", "index"=>0}
```

It's also possible to load input OutPoint from different index:

```ruby
CKB.load_input_out_point(1, CKB::Source::INPUT)
# This won't trigger errors but would always return nil since output doesn't have
# OutPoint
CKB.load_input_out_point(1, CKB::Source::OUTPUT)
```

#### Load Cell By Field

We can also load certain field in a cell:

```ruby
# Capacity is serialized into 8-byte little endian bytes
capacity = CKB::CellField.new(CKB::Source::INPUT, 1, CKB::CellField::CAPACITY).read(0, 8).unpack("Q<")[0]
# Data is stored as raw bytes, readall here can be used to fetch all the data
data = CKB::CellField.new(CKB::Source::OUTPUT, 2, CKB::CellField::DATA).readall
# Lock and contract hash are returned as 32 byte string
lock_hash_length = CKB::CellField.new(CKB::Source::CURRENT, 0, CKB::CellField::LOCK_HASH).length
unless length == 32
  raise "Lock hash has invalid length!"
end
contract_hash = CKB::CellField.new(CKB::Source::OUTPUT, 0, CKB::CellField::LOCK_HASH).read(16, 16)
```
